<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>å®¢æˆ·è·Ÿè¿›è¯¦æƒ…è¡¨ - å®Œæ•´ç‰ˆï¼ˆå«åˆå¹¶å¯¼å…¥/å¯¼å‡ºæŒ‰é’®ï¼‰</title>
  <style>
    :root{--bg:#f6f8fb;--card:#fff;--accent:#2563eb;--muted:#61748a;--danger:#dc2626}
    *{box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial;background:var(--bg);margin:0;padding:24px;color:#0f172a}
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;gap:12px}
    h1{font-size:22px;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    select,button{font-size:14px;padding:6px 12px;border-radius:8px;border:1px solid #d0d7e8;background:#fff}
    button{cursor:pointer;background:var(--accent);color:#fff;border:none}
    .ghost{background:transparent;border:1px solid #d0d7e8;color:var(--accent)}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .card{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(16,24,40,0.06)}
    .card h2{margin:0 0 8px;font-size:16px}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    textarea.field{width:100%;min-height:32px;max-height:240px;padding:6px 10px;border-radius:8px;border:1px solid #e6eefb;background:#fbfdff;resize:none;font-size:14px;line-height:1.4}
    textarea.field:focus{outline:none;box-shadow:0 6px 18px rgba(37,99,235,0.08);border-color:rgba(37,99,235,0.25)}
    .section{margin-top:16px}
    .progress-area{margin-top:10px;background:var(--card);padding:12px;border-radius:10px;box-shadow:0 4px 12px rgba(16,24,40,0.04)}
    .progress-list{display:flex;flex-direction:column;gap:8px}
    .step{display:flex;gap:8px;align-items:flex-start}
    .step .field{flex:1}
    .delete-btn{background:transparent;border:none;color:var(--danger);cursor:pointer;font-weight:600}
    .delete-btn:hover{color:#991b1b}
    .small{font-size:13px;color:var(--muted)}
    footer{margin-top:12px;display:flex;justify-content:flex-end;gap:8px}
    @media(max-width:780px){.cards{grid-template-columns:1fr 1fr}}

    .dropdown{position:relative;}
    .dropdown-menu{position:absolute;background:#fff;border:1px solid #d0d7e8;padding:6px 0;border-radius:8px;display:none;min-width:160px;box-shadow:0 4px 12px rgba(0,0,0,0.12);z-index:99}
    .dropdown-item{padding:8px 14px;font-size:14px;cursor:pointer;white-space:nowrap}
    .dropdown-item:hover{background:#f1f5ff;color:#2563eb}

    /* Modal */
    #modal {
      position: fixed;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.45);
      z-index: 9999;
      padding: 16px;
    }
    #modalCard {
      background: #fff;
      padding: 18px;
      width: 520px;
      max-width: calc(100% - 32px);
      border-radius: 12px;
      box-shadow: 0 8px 36px rgba(2,6,23,0.2);
    }
    #modalTitle{margin:0 0 8px;font-size:18px;color:#0f172a}
    #modalBody{margin-top:8px}
    #modalInput, #modalTextarea {
      width:100%; border-radius:8px; border:1px solid #e6eefb; padding:8px; font-size:14px; min-height:36px;
    }
    #modalFooter{margin-top:12px;display:flex;justify-content:flex-end;gap:8px}

    /* Toasts */
    .toast {
      position: fixed;
      right: 20px;
      bottom: 20px;
      padding: 10px 14px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.12);
      color: #fff;
      opacity: 0;
      transition: all .28s ease;
      z-index: 10000;
    }
    .toast.show { opacity: 1; transform: translateY(0); }
    .toast.success { background: rgba(16,185,129,0.95); }
    .toast.error { background: rgba(220,38,38,0.95); }
    /* hidden file input */
    #fileInput { display:none; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>å®¢æˆ·è·Ÿè¿›è¯¦æƒ…è¡¨</h1>
        <div class="small">æ¡Œé¢å¹¶æ’å¡ç‰‡ Â· Shift+Enter æ¢è¡Œ Â· Enter ä¿å­˜</div>
      </div>

      <div class="controls">
        <label class="small" style="margin-right:6px">å½“å‰å®¢æˆ·</label>
        <select id="clientSelect"></select>
        <button id="addClient">+ æ–°å®¢æˆ·</button>
        <button id="renameClient" class="ghost">ä¿®æ”¹åç§°</button>
        <button id="deleteClient" class="ghost delete-btn">åˆ é™¤å®¢æˆ·</button>

        <!-- åˆå¹¶æŒ‰é’® -->
        <div class="dropdown">
          <button id="ioMainBtn" class="ghost">å¯¼å…¥ / å¯¼å‡º</button>
          <div id="ioMenu" class="dropdown-menu" role="menu" aria-hidden="true">
            <div class="dropdown-item" id="importText">ğŸ“‹ ç²˜è´´æ–‡æœ¬å¯¼å…¥</div>
            <div class="dropdown-item" id="uploadText">ğŸ“„ ä¸Šä¼  .txt æ–‡ä»¶å¯¼å…¥</div>
            <div class="dropdown-item" id="exportClientBtn">â¬‡ï¸ å¯¼å‡ºå½“å‰å®¢æˆ·</div>
            <div class="dropdown-item" id="exportAllBtn">â¬‡ï¸ å¯¼å‡ºå…¨éƒ¨å®¢æˆ·</div>
          </div>
        </div>

        <input type="file" id="fileInput" accept=".txt,text/plain">
      </div>
    </header>

    <div class="cards">
      <div class="card">
        <h2>å®¢æˆ·ä¿¡æ¯</h2>
        <label>å§“å / å¹´é¾„ / åœ°åŒº</label>
        <textarea class="field" data-key="client_basic"></textarea>
        <label style="margin-top:8px">å©šå§»ä¸å®¶åº­</label>
        <textarea class="field" data-key="client_family"></textarea>
        <label style="margin-top:8px">å·¥ä½œç»å†</label>
        <textarea class="field" data-key="client_job"></textarea>
        <label style="margin-top:8px">å·¥ä½œæ—¶é—´</label>
        <textarea class="field" data-key="client_time"></textarea>
        <label style="margin-top:8px">å…´è¶£çˆ±å¥½</label>
        <textarea class="field" data-key="client_hobby"></textarea>
      </div>

      <div class="card">
        <h2>å¥³ä¸»ä¿¡æ¯</h2>
        <label>å§“å / å¹´é¾„ / åœ°åŒº</label>
        <textarea class="field" data-key="hero_basic"></textarea>
        <label style="margin-top:8px">å©šå§»ä¸å®¶åº­</label>
        <textarea class="field" data-key="hero_family"></textarea>
        <label style="margin-top:8px">å·¥ä½œæƒ…å†µ</label>
        <textarea class="field" data-key="hero_job"></textarea>
        <label style="margin-top:8px">å·¥ä½œæ—¶é—´</label>
        <textarea class="field" data-key="hero_time"></textarea>
        <label style="margin-top:8px">å…´è¶£çˆ±å¥½</label>
        <textarea class="field" data-key="hero_hobby"></textarea>
      </div>
    </div>

    <div class="section">
      <h3>å…¶ä»–æƒ…å†µ</h3>
      <textarea class="field" data-key="extra" style="min-height:80px"></textarea>
    </div>

    <div class="section">
      <h3>æŠ•èµ„æ¨è¿›è®°å½•</h3>
      <div class="progress-area">
        <div id="progress" class="progress-list"></div>
        <div style="margin-top:10px;display:flex;gap:8px">
          <button id="addStep">+ æ·»åŠ è®°å½•</button>
          <button id="clearAll" class="ghost">æ¸…ç©ºæ‰€æœ‰</button>
        </div>
      </div>
    </div>

    <footer><div class="small" id="lastSaved"></div></footer>
  </div>

  <!-- Modal -->
  <div id="modal" aria-hidden="true">
    <div id="modalCard" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <h3 id="modalTitle"></h3>
      <div id="modalBody">
        <!-- dynamic -->
        <textarea id="modalTextarea" style="display:none;"></textarea>
        <input id="modalInput" style="display:none;" />
        <div id="modalExtra" style="display:none;margin-top:8px"></div>
      </div>
      <div id="modalFooter">
        <button id="modalCancel" class="ghost">å–æ¶ˆ</button>
        <button id="modalOK">ç¡®å®š</button>
      </div>
    </div>
  </div>

  <!-- Toasts -->
  <div id="toast" class="toast success" role="status" aria-live="polite"></div>
  <div id="toastError" class="toast error" role="status" aria-live="polite"></div>

  <script>
    // helpers
    function genId(){return 'id_'+Math.random().toString(36).slice(2,9);}
    const emptyClient = {client_basic:'',client_family:'',client_job:'',client_time:'',client_hobby:'',hero_basic:'',hero_family:'',hero_job:'',hero_time:'',hero_hobby:'',extra:'',progress:[]};
    const STORAGE_KEY = 'clients_data_v6';
    const loadAll = ()=>{ try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); } catch(e) { return {}; } };
    const saveAll = (obj)=>localStorage.setItem(STORAGE_KEY,JSON.stringify(obj));

    // toast helpers
    const toastEl = document.getElementById('toast');
    const toastErrEl = document.getElementById('toastError');
    let toastTimer = null;
    function showToast(msg, type='success', ms=1600){
      clearTimeout(toastTimer);
      if(type==='error'){
        toastErrEl.textContent = msg;
        toastErrEl.classList.add('show');
        toastEl.classList.remove('show');
        toastTimer = setTimeout(()=>{ toastErrEl.classList.remove('show'); }, ms);
      } else {
        toastEl.textContent = msg;
        toastEl.classList.add('show');
        toastErrEl.classList.remove('show');
        toastTimer = setTimeout(()=>{ toastEl.classList.remove('show'); }, ms);
      }
    }

    // modal helper (callback style)
    function showModal(options, callback){
      // options: { title, placeholder, defaultValue, textarea:boolean, extraHtml }
      const modal = document.getElementById('modal');
      const title = document.getElementById('modalTitle');
      const textarea = document.getElementById('modalTextarea');
      const input = document.getElementById('modalInput');
      const extra = document.getElementById('modalExtra');

      title.textContent = options.title || '';
      textarea.style.display = options.textarea ? 'block' : 'none';
      input.style.display = options.textarea ? 'none' : 'block';
      extra.style.display = options.extraHtml ? 'block' : 'none';

      if(options.textarea){
        textarea.value = options.defaultValue || '';
        textarea.placeholder = options.placeholder || '';
        textarea.focus();
      } else {
        input.value = options.defaultValue || '';
        input.placeholder = options.placeholder || '';
        input.type = options.type || 'text';
        input.focus();
      }

      extra.innerHTML = options.extraHtml || '';

      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden','false');

      const okBtn = document.getElementById('modalOK');
      const cancelBtn = document.getElementById('modalCancel');

      function cleanup(){
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden','true');
        okBtn.onclick = null;
        cancelBtn.onclick = null;
        document.onkeydown = null;
      }

      okBtn.onclick = ()=> {
        const value = options.textarea ? textarea.value : input.value;
        cleanup(); callback(value);
      };
      cancelBtn.onclick = ()=> { cleanup(); callback(null); };

      document.onkeydown = function(e){
        if(e.key === 'Escape'){ cleanup(); callback(null); }
        if(e.key === 'Enter' && !e.shiftKey){
          // if textarea visible, ignore Enter (user may want newline). For inputs, treat Enter as OK
          if(!options.textarea){ cleanup(); callback(input.value); }
        }
      };
    }

    // state
    let clients = loadAll();
    if(Object.keys(clients).length===0){ clients['æ´‹ä¸€'] = JSON.parse(JSON.stringify(emptyClient)); saveAll(clients); }

    const select = document.getElementById('clientSelect');
    const fields = document.querySelectorAll('textarea.field[data-key]');
    const progressEl = document.getElementById('progress');
    const lastSavedEl = document.getElementById('lastSaved');

    let current = Object.keys(clients)[0];

    // render select
    function renderSelect(){
      const names = Object.keys(clients);
      select.innerHTML = '';
      names.forEach(n=>{
        const o = document.createElement('option'); o.value = n; o.textContent = n; select.appendChild(o);
      });
      // if current no longer exists, pick first
      if(!clients[current] && names.length>0) current = names[0];
      select.value = current || (names[0]||'');
    }

    function autoResize(el){ el.style.height = 'auto'; el.style.height = Math.max(32, el.scrollHeight) + 'px'; }

    // saveClient supports optional showToast flag
    function saveClient(showToast = true){
      if(!current) return;
      const d = clients[current] || (clients[current] = JSON.parse(JSON.stringify(emptyClient)));
      fields.forEach(f => { d[f.dataset.key] = f.value; });
      d.__lastSaved = new Date().toLocaleString();
      saveAll(clients);
      updateLastSaved();
      if(showToast) showToastFn('å·²ä¿å­˜');
    }

    // wrapper to avoid name collision with showToast
    function showToastFn(msg){ showToast(msg, 'success'); }

    function showError(msg){ showToast(msg, 'error'); }

    function loadClient(name){
      // save current (only if exists and different from target)
      if(current && clients[current] && current !== name){
        saveClient(false);
      }
      current = name;
      const d = clients[name] || JSON.parse(JSON.stringify(emptyClient));
      if(!d.progress) d.progress = [];
      fields.forEach(f => { f.value = d[f.dataset.key] || ''; autoResize(f); });
      renderProgress();
      renderSelect();
      updateLastSaved();
    }

    function renderProgress(){
      progressEl.innerHTML = '';
      const list = (clients[current] && clients[current].progress) ? clients[current].progress : [];
      list.forEach(item => {
        const row = document.createElement('div'); row.className = 'step';
        const ta = document.createElement('textarea'); ta.className = 'field';
        ta.value = item.text || ''; autoResize(ta);
        ta.addEventListener('input', ()=>autoResize(ta));
        ta.addEventListener('keydown', e => { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); ta.blur(); }});
        ta.addEventListener('blur', ()=>{ item.text = ta.value; saveClient(); renderProgress(); });
        const del = document.createElement('button'); del.textContent = 'åˆ é™¤'; del.className = 'ghost';
        del.onclick = ()=>{ clients[current].progress = clients[current].progress.filter(x=>x.id!==item.id); saveClient(); renderProgress(); };
        row.append(ta, del);
        progressEl.append(row);
      });
    }

    // bind fields
    fields.forEach(f=>{
      autoResize(f);
      f.addEventListener('input', ()=>autoResize(f));
      f.addEventListener('keydown', e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); f.blur(); } });
      f.addEventListener('blur', ()=> saveClient(true));
    });

    // add step
    document.getElementById('addStep').addEventListener('click', ()=>{
      if(!clients[current]) clients[current] = JSON.parse(JSON.stringify(emptyClient));
      const step = { id: genId(), text: '' };
      clients[current].progress.push(step);
      saveAll(clients);
      renderProgress();
      requestAnimationFrame(()=>{ const last = progressEl.querySelectorAll('textarea.field'); if(last.length) last[last.length-1].focus(); });
    });

    // clear all with modal confirm
    document.getElementById('clearAll').addEventListener('click', ()=>{
      showModal({ title: 'æ¸…ç©ºæ‰€æœ‰æ¨è¿›è®°å½•', textarea: false, defaultValue: '', placeholder: 'è¾“å…¥ YES ç¡®è®¤æ¸…ç©º' }, (v)=>{
        if(v === 'YES'){
          if(clients[current]) clients[current].progress = [];
          saveClient();
          renderProgress();
          showToastFn('æ¨è¿›è®°å½•å·²æ¸…ç©º');
        } else if(v !== null) {
          showToastFn('å·²å–æ¶ˆ');
        }
      });
    });

    // ADD CLIENT â€” use modal
    document.getElementById('addClient').addEventListener('click', ()=>{
      showModal({ title: 'è¯·è¾“å…¥æ–°å®¢æˆ·åç§°', textarea: false, defaultValue: '' }, (name)=>{
        if(!name) { showToastFn('å·²å–æ¶ˆ'); return; }
        if(clients[name]){
          showModal({ title: 'å®¢æˆ·å·²å­˜åœ¨ï¼Œæ˜¯å¦åˆ‡æ¢ï¼Ÿè¾“å…¥ YES åˆ‡æ¢', textarea: false, defaultValue: '' }, (ans)=>{
            if(ans === 'YES') loadClient(name);
            else showToastFn('å·²å–æ¶ˆ');
          });
          return;
        }
        // create empty client
        clients[name] = JSON.parse(JSON.stringify(emptyClient));
        saveAll(clients);
        loadClient(name);
        renderSelect();
        saveClient(true);
        showToastFn('å·²åˆ›å»ºæ–°å®¢æˆ·ï¼š' + name);
      });
    });

    // RENAME CLIENT
    document.getElementById('renameClient').addEventListener('click', ()=>{
      if(!current) { showError('æ— å½“å‰å®¢æˆ·'); return; }
      showModal({ title: 'ä¿®æ”¹å®¢æˆ·åç§°', textarea: false, defaultValue: current }, (newName)=>{
        if(newName === null){ showToastFn('å·²å–æ¶ˆ'); return; }
        newName = newName.trim();
        if(!newName){ showError('åç§°ä¸èƒ½ä¸ºç©º'); return; }
        if(newName === current){ showToastFn('åç§°æœªæ”¹å˜'); return; }
        if(clients[newName]){ showError('åç§°å·²å­˜åœ¨ï¼Œè¯·ä½¿ç”¨å…¶ä»–åç§°'); return; }

        clients[newName] = clients[current];
        delete clients[current];
        saveAll(clients);
        current = newName;
        renderSelect();
        loadClient(newName);
        showToastFn('å·²é‡å‘½åä¸ºï¼š' + newName);
      });
    });

    // DELETE CLIENT
    document.getElementById('deleteClient').addEventListener('click', ()=>{
      if(!current) { showError('æ— å½“å‰å®¢æˆ·'); return; }
      showModal({ title: 'åˆ é™¤å®¢æˆ·ç¡®è®¤', textarea: false, defaultValue: '', placeholder: 'è¾“å…¥ DELETE ç¡®è®¤' }, (v)=>{
        if(v === 'DELETE'){
          delete clients[current];
          saveAll(clients);
          const keys = Object.keys(clients);
          if(keys.length>0) loadClient(keys[0]);
          else { clients['æ–°å®¢æˆ·'] = JSON.parse(JSON.stringify(emptyClient)); saveAll(clients); loadClient('æ–°å®¢æˆ·'); }
          renderSelect();
          showToastFn('å®¢æˆ·å·²åˆ é™¤');
        } else {
          showToastFn('å·²å–æ¶ˆ');
        }
      });
    });

    select.addEventListener('change', ()=> loadClient(select.value));

    // EXPORT FUNCTIONS (unchanged logic)
    function exportClient(name){
      const d = clients[name] || emptyClient;
      const lines = [];
      lines.push('å®¢æˆ·ï¼š' + (name||''));
      lines.push('å®¢æˆ·ä¿¡æ¯');
      lines.push('å§“å / å¹´é¾„ / åœ°åŒºï¼š' + (d.client_basic||''));
      lines.push('å©šå§»ä¸å®¶åº­ï¼š' + (d.client_family||''));
      lines.push('å·¥ä½œç»å†ï¼š' + (d.client_job||''));
      lines.push('å·¥ä½œæ—¶é—´ï¼š' + (d.client_time||''));
      lines.push('å…´è¶£çˆ±å¥½ï¼š' + (d.client_hobby||''));
      lines.push('');
      lines.push('å¥³ä¸»ä¿¡æ¯');
      lines.push('å§“å / å¹´é¾„ / åœ°åŒºï¼š' + (d.hero_basic||''));
      lines.push('å©šå§»ä¸å®¶åº­ï¼š' + (d.hero_family||''));
      lines.push('å·¥ä½œæƒ…å†µï¼š' + (d.hero_job||''));
      lines.push('å·¥ä½œæ—¶é—´ï¼š' + (d.hero_time||''));
      lines.push('å…´è¶£çˆ±å¥½ï¼š' + (d.hero_hobby||''));
      lines.push('');
      lines.push('å…¶ä»–æƒ…å†µ');
      lines.push(d.extra || '');
      lines.push('');
      lines.push('æŠ•èµ„æ¨è¿›è®°å½•');
      (d.progress||[]).forEach((p,i)=> lines.push((i+1)+'. '+(p.text||'')));
      lines.push('');
      lines.push('å¯¼å‡ºæ—¶é—´ï¼š' + new Date().toLocaleString());
      const text = lines.join('\n');
      const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
      const safe = (name||'å®¢æˆ·').replace(/[^\\w\\u4e00-\\u9fa5-]/g,'_');
      a.download = `å®¢æˆ·_${safe}_è®°å½•.txt`;
      a.click(); URL.revokeObjectURL(a.href);
      showToastFn('å·²å¯¼å‡ºï¼š' + a.download);
    }

    function exportAll(){
      const parts = [];
      Object.keys(clients).forEach(name=>{
        const d = clients[name] || emptyClient;
        parts.push('====================');
        parts.push('ã€å®¢æˆ·ï¼š' + name + 'ã€‘');
        parts.push('====================');
        parts.push('å§“å / å¹´é¾„ / åœ°åŒºï¼š' + (d.client_basic||''));
        parts.push('å©šå§»ä¸å®¶åº­ï¼š' + (d.client_family||''));
        parts.push('å·¥ä½œç»å†ï¼š' + (d.client_job||''));
        parts.push('å·¥ä½œæ—¶é—´ï¼š' + (d.client_time||''));
        parts.push('å…´è¶£çˆ±å¥½ï¼š' + (d.client_hobby||''));
        parts.push('');
        parts.push('å¥³ä¸»ä¿¡æ¯ï¼š' + (d.hero_basic||''));
        parts.push('å©šå§»ä¸å®¶åº­ï¼š' + (d.hero_family||''));
        parts.push('å·¥ä½œæƒ…å†µï¼š' + (d.hero_job||''));
        parts.push('å·¥ä½œæ—¶é—´ï¼š' + (d.hero_time||''));
        parts.push('å…´è¶£çˆ±å¥½ï¼š' + (d.hero_hobby||''));
        parts.push('');
        parts.push('å…¶ä»–æƒ…å†µï¼š' + (d.extra||''));
        parts.push('');
        parts.push('æŠ•èµ„æ¨è¿›è®°å½•ï¼š');
        (d.progress||[]).forEach((p,i)=> parts.push('  ' + (i+1) + '. ' + (p.text||'')));
        parts.push('\n');
      });
      parts.push('å¯¼å‡ºæ—¶é—´ï¼š' + new Date().toLocaleString());
      const text = parts.join('\n');
      const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
      a.download = 'æ‰€æœ‰å®¢æˆ·è®°å½•.txt';
      a.click(); URL.revokeObjectURL(a.href);
      showToastFn('å·²å¯¼å‡ºæ‰€æœ‰å®¢æˆ·');
    }

    // IMPORT â€” parsing logic (kept from original)
    function processImportedText(txt){
      // try to extract a sensible name
      let nameMatch = txt.match(/^(?:å§“å|å®¢æˆ·|Name)[\\s\\S]{0,12}?[:ï¼š]\\s*([^\\n\\r]+)/i);
      let name = nameMatch ? nameMatch[1].trim() : ("å¯¼å…¥å®¢æˆ·_" + Date.now());

      // if name exists, ask whether to overwrite or rename
      if(clients[name]){
        showModal({ title: 'å®¢æˆ·å·²å­˜åœ¨ï¼Œè¾“å…¥ O è¦†ç›– / R é‡å‘½å / C å–æ¶ˆ', textarea:false, defaultValue:'' }, (opt)=>{
          if(opt === 'O'){ actuallyImport(name, txt, true); }
          else if(opt === 'R'){ showModal({ title:'è¾“å…¥æ–°å®¢æˆ·å', textarea:false, defaultValue: name }, (newName)=>{ if(newName) actuallyImport(newName, txt, false); else showToastFn('å·²å–æ¶ˆ'); }); }
          else { showToastFn('å·²å–æ¶ˆ'); }
        });
      } else {
        actuallyImport(name, txt, false);
      }
    }

    function actuallyImport(name, txt, overwrite){
      try {
        const d = JSON.parse(JSON.stringify(emptyClient));

        function extractOnce(regex){
          const m = txt.match(regex);
          return m ? m[1].trim() : '';
        }

        d.client_basic = extractOnce(/(?:å§“å|å®¢æˆ·å§“å|å®¢æˆ·).*?[:ï¼š]\\s*([^\\n\\r]+)/i) || extractOnce(/å§“å.*?[:ï¼š]\\s*([^\\n\\r]+)/i) || extractOnce(/Name.*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.client_family = extractOnce(/å©šå§»ä¸å®¶åº­.*?[:ï¼š]\\s*([^\\n\\r]+)/i) || extractOnce(/å©šå§».*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.client_job    = extractOnce(/å·¥ä½œ(?:ç»å†|æƒ…å†µ).*?[:ï¼š]\\s*([^\\n\\r]+)/i) || extractOnce(/å·¥ä½œ.*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.client_time   = extractOnce(/å·¥ä½œæ—¶é—´.*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.client_hobby  = extractOnce(/å…´è¶£çˆ±å¥½.*?[:ï¼š]\\s*([^\\n\\r]+)/i);

        d.hero_basic = extractOnce(/å¥³ä¸».*?å§“å.*?[:ï¼š]\\s*([^\\n\\r]+)/i) || extractOnce(/å¥³ä¸»å§“å.*?[:ï¼š]\\s*([^\\n\\r]+)/i) || extractOnce(/å¥³ä¸».*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.hero_family = extractOnce(/å¥³ä¸».*?å©šå§».*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.hero_job    = extractOnce(/å¥³ä¸».*?å·¥ä½œ.*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.hero_time   = extractOnce(/å¥³ä¸».*?å·¥ä½œæ—¶é—´.*?[:ï¼š]\\s*([^\\n\\r]+)/i);
        d.hero_hobby  = extractOnce(/å¥³ä¸».*?å…´è¶£.*?[:ï¼š]\\s*([^\\n\\r]+)/i);

        d.extra = (txt.match(/å…¶ä»–æƒ…å†µ.*?[:ï¼š]\\s*([\\s\\S]*?)(\\n|$)/i) || ['',''])[1] || '';

        // æŠ•èµ„æ¨è¿›è®°å½• - look for section heading then lines starting with numbers or '-'
        d.progress = [];
        const progSection = txt.match(/æŠ•èµ„æ¨è¿›è®°å½•[\\s\\S]*/i);
        if(progSection){
          const lines = progSection[0].split(/\\r?\\n/).slice(1);
          lines.forEach(line=>{
            const t = line.replace(/^\\s*[\\-\\*]?\\s*\\d*\\.*\\s*/, '').trim();
            if(t) d.progress.push({ id: genId(), text: t });
          });
        } else {
          // fallback: find lines that look like '1. ...' anywhere
          const matches = txt.match(/^\\s*\\d+\\.\\s+.+$/gm);
          if(matches) matches.forEach(m=> d.progress.push({id:genId(), text: m.replace(/^\\s*\\d+\\.\\s*/,'').trim()}));
        }

        if(!overwrite && clients[name]){
          name = name + '_' + Date.now();
        }

        clients[name] = d;
        saveAll(clients);
        current = name;
        renderSelect();
        loadClient(name);
        showToastFn('å¯¼å…¥æˆåŠŸï¼š' + name);
      } catch (e) {
        console.error(e);
        showError('å¯¼å…¥å¤±è´¥ï¼šè§£æé”™è¯¯');
      }
    }

    // File upload handling
    const fileInput = document.getElementById('fileInput');
    fileInput.addEventListener('change', function(e){
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      if(!f.type.includes('text') && !f.name.endsWith('.txt')) { showError('åªæ”¯æŒæ–‡æœ¬æ–‡ä»¶ (.txt)'); e.target.value = ''; return; }
      const reader = new FileReader();
      reader.onload = function(ev){
        const txt = ev.target.result;
        processImportedText(txt);
      };
      reader.readAsText(f, 'utf-8');
      // reset input so same file can be uploaded again later
      e.target.value = '';
    });

    // Dropdown behavior and binding to actions
    const ioBtn = document.getElementById('ioMainBtn');
    const ioMenu = document.getElementById('ioMenu');
    const importTextBtn = document.getElementById('importText');
    const uploadTextBtn = document.getElementById('uploadText');
    const exportClientBtn = document.getElementById('exportClientBtn');
    const exportAllBtn = document.getElementById('exportAllBtn');

    ioBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const visible = ioMenu.style.display === 'block';
      ioMenu.style.display = visible ? 'none' : 'block';
      ioMenu.setAttribute('aria-hidden', visible ? 'true' : 'false');
    });

    // close menu when clicking outside
    document.addEventListener('click', (e)=>{
      if(!ioBtn.contains(e.target) && !ioMenu.contains(e.target)){
        ioMenu.style.display = 'none';
        ioMenu.setAttribute('aria-hidden', 'true');
      }
    });

    // paste-text import
    importTextBtn.addEventListener('click', ()=>{
      ioMenu.style.display = 'none';
      showModal({ title: 'ç²˜è´´å®¢æˆ·æ–‡æœ¬å†…å®¹ï¼ˆæ”¯æŒå¸¸è§å­—æ®µï¼‰', textarea: true, defaultValue: '', placeholder: 'å°†æ–‡æœ¬ç²˜è´´åˆ°æ­¤å¤„ï¼Œç„¶åç‚¹å‡»ç¡®å®š' }, (txt)=>{
        if(!txt){ showToastFn('å·²å–æ¶ˆ'); return; }
        processImportedText(txt);
      });
    });

    // upload file import
    uploadTextBtn.addEventListener('click', ()=>{
      ioMenu.style.display = 'none';
      fileInput.click();
    });

    // export actions
    exportClientBtn.addEventListener('click', ()=>{
      ioMenu.style.display = 'none';
      if(!current){ showError('æ— å½“å‰å®¢æˆ·'); return; }
      exportClient(current);
    });
    exportAllBtn.addEventListener('click', ()=>{
      ioMenu.style.display = 'none';
      exportAll();
    });

    function updateLastSaved(){ lastSavedEl.textContent = 'ä¸Šæ¬¡ä¿å­˜ï¼š' + (clients[current] && clients[current].__lastSaved ? clients[current].__lastSaved : 'â€”'); }

    // init
    renderSelect();
    loadClient(current);

    // Accessibility: focus trapping not implemented (kept simple)
  </script>
</body>
</html>
